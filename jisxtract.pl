#!/usr/bin/perl -CS
#
#	JISxtract v0.3 -- ShiftJIS extractor 
#
#   Copyright 2014-2020, Giovanni Nunes <giovanni.nunes@gmail.com>
#
#	This program is free software; you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation; either version 2 of the License, or
#	(at your option) any later version.
#	
#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
#	GNU General Public License for more details.
#	
#	You should have received a copy of the GNU General Public License
#	along with this program; if not, write to the Free Software
#	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#	MA 02110-1301, USA.
#	
	use Encode qw(decode encode);
	use strict;
	use utf8;
	use warnings;

    # my numbers
	#
	my ( $i, $j, $k, $l);
	my ( $byte, $filesize, $jf, $locate );

	# my strings
	#
	my $content='';
	my $filename='';
	my $jis='';
	my $text='';
	my $utf='';

	$filename=$ARGV[0];

	if  ( -f $filename )
	{
		open(my $fh, '<', $filename)
		or die "Could not open file '$filename' $!";
		
			binmode STDOUT,":raw";
			binmode $fh,":raw";
			$filesize=-s $filename;
			read $fh,$content,$filesize;
		
		close($fh);
		
		$i=0;
		$jf=0;
		$text="";
		
		# create a "nice" HTML file
		#
		print	"<html>\n".
				"<head>\n".
				"<title>".$filename." - (".$filesize." bytes)</title>\n".
				"<meta http-equiv='Content-Type' CONTENT='text/html;charset=Shift-JIS'>\n".
				"</head>\n\n";
		
		# someday a CSS here....
		#
		print	"<body>\n".
				"<h1>".$filename." - (".$filesize." bytes)</h1>\n";
		
		print "<table>\n".
				"<tr>".
				"<th>POSITION</th>".
				"<th>SIZE</th>".
				"<th>HEX DUMP</th>".
				"<th>JIS DUMP</th>".
				"<th>ASCII</th>".
				"</tr>\n";
		
		$jf=0;
		
		# that the extracion begins!
		#
		while($i<$filesize)
		{
			# read a byte
			#
			$byte=ord substr($content,$i,1);
			
			# is NULL and I'm catching JIS codes?
            # Then is the end of string and let's print!
			#
			if ( $byte==0 and $jf==1 )
			{
				print	"<tr>".
						"<td>0x".sprintf('%08x',$locate)."</td>".
						"<td>".length($text)."</td>".
						"<td>";
				
				# generates a hex dump of string
				#
				for($j=0; $j<length($text); $j++)
				{
					print sprintf('%02x',ord(substr($text,$j,1)))." ";
				}
				
				print	"</td>".
						"<td>".$text."</td>".
						"<td>&quot;&nbsp;&quot;</td>".
						"</tr>\n";
					
				$jf=0;
				$text="";
			}
			
			#
			#	You can obtain more information about Shift JIS visiting:
			#	http://en.wikipedia.org/wiki/Shift_JIS
			#	http://www.rikai.com/library/kanjitables/kanji_codes.sjis.shtml
			#
			
			# is 'byte' between J1 bondaries?
			#
			if ( $byte>0x80 and $byte<0xfd )
			{
				$jis=chr($byte);
				$byte=ord substr($content,($i+1),1);
				
				# is byte between J2 bondaries?
				#
				if ( $byte>0x3e and $byte<0xff )
				{
					$jis.=chr($byte);
					$utf=Encode::encode("shiftjis",$jis);
					
					# convert to UTF-8 to verify if is a valid code (dirty? I know!)
					#
					if ( ord($utf)!=0xfffd )
					{
						# if not catching JIS, let's catch start it!
						#
						if ( $jf==0 )
						{
							$jf=1;
							$locate=$i;
						}
						$text.=$jis;
						$i++;
					}
					else
					{
						# isn't JIS code, ignore all
						#
						$jf=0;
						$text="";
					}
				}
				else
				{
					# isn't JIS code, reset too!
					#
					$jf=0;
					$text="";
				}
			}
			elsif ( $byte>0x2f and $byte<0x80 and $jf==1 )
			{
				# can exist both ASCII and JIS codes in same strings
				#
				$text.=chr($byte);
			}
			else
			{
				# reset too... again :-)
				#
				$jf=0;
				$text="";
			}
			
			# increment my counter
			#
			$i++;
		}
		
		# finish table and HTML file
		#
		print	"</table>\n".
				"</body>\n".
				"</html>\n";
		
		print	"<!-- generated by JISxtract -->\n";
	}
